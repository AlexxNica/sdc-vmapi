---
title: VMs API (VMAPI)
apisections: Ping, VMs, VM Snapshots, VM Metadata, Jobs, Changelog
markdown2extras: wiki-tables, code-friendly
---

# VMAPI

* Repository: git clone git@git.joyent.com:vmapi.git
* Browsing: <https://mo.joyent.com/vmapi>
* Docs: <https://mo.joyent.com/docs/vmapi>
* Who: Andres Rodriguez
* Tickets/bugs: <https://devhub.joyent.com/jira/browse/VMAPI>

# Introduction to VMs API

## What is VMAPI?

VMs API allows clients to get information about VMs on a datacenter by using an HTTP API. VMAPI offers the following features:

 * Search VMs by specific criteria such as ram, owner, tags, server, image, etc.
 * Get information about a single VM
 * Create new VMs
 * Perform actions on an existing VM such as start, stop, reboot and resize
 * List jobs that have been created for VMs
 * Update VMs
 * Destroy VMs
 * Manage VM metadata

## Design & Requirements

* Node.js restify HTTP server
* UFDS is the remote datastore for VMAPI. VMAPI does not have persistency and VM data living on UFDS should be considered a cache
* A heartbeater AMQP client listens for VM heartbeats so VMAPI can return state information for zones
* VMAPI is only concerned for exposing VMs information to users the same way CNAPI does for compute nodes
* There is one VMAPI instance per datacenter
* VMAPI is stateless: when any VM action is called (create, destroy, reboot, etc) the message is passed through a workflow API instance that takes care of it
* VMAPI should be as dumb as possible. Contrary to MAPI, VMAPI does not have complicated logic that prevents users to call actions on VMs (and even creating VMs). Much of the required logic for this is moved to the corresponding workflow and other participant APIs


# Getting Started

You can set your own local install of VMAPI assuming you are also running a local (or remote if accessible) COAL instance with the master branch of UFDS:

    # Get the source and build.
    git clone git@git.joyent.com:vmapi.git
    cd vmapi/
    make all

    # Setup config.
    # Note that there is a dependency on a headnode instance with a running UFDS
    cp config.mac.json config.json
    vi config.json

    # node server.js


# VM Response Object

The VM response object is going a single representation for the two available VM GET actions. GET /vms will return a collection of VM objects and GET /vms/<uuid> will return a single VM object. This object will conform to the attributes shown below as they reflect the same VM attributes found when issuing a `vmadm get <uuid>` command from the command line interface on a SDC compute node. Note that vmadm returns more attributes that might not be relevant at the HTTP API layer.

    {
      "uuid": "ef375f03-57ca-44a9-bc8d-63aec09fbc37",
      "brand": "joyent",
      "dataset_uuid": "01b2c898-945f-11e1-a523-af1afbe22822",
      "image_uuid": "01b2c898-945f-11e1-a523-af1afbe22822",
      "server_uuid": "564d6836-ed2e-18f8-bdf2-e900490a57a1",
      "alias": "assets1",
      "ram": 64,
      "max_physical_memory": 64,
      "max_swap": 256,
      "quota": 10240,
      "cpu_cap": 100,
      "cpu_shares": 1,
      "max_lwps": 1000,
      "create_timestamp": "2012-05-16T23:33:09.809Z",
      "destroyed": "",
      "last_modified": "2012-05-16T23:33:12.000Z",
      "zone_state": "running",
      "state": "running",
      "zpool": "zones",
      "zfs_io_priority": 10,
      "owner_uuid": "930896af-bf8c-48d4-885c-6573a94b1853",
      "nics": [
        {
          "interface": "net0",
          "mac": "90:b8:d0:d6:26:6e",
          "vlan_id": 0,
          "nic_tag": "admin",
          "ip": "10.99.99.192",
          "netmask": "255.255.255.0",
          "gateway": "10.99.99.7",
          "primary": true
        }
      ],
      "resolvers": [
        "10.99.99.11"
      ],
      "customer_metadata": {
        "host-ip": "10.99.99.9"
      },
      "internal_metadata": {
          "throttle": true
      },
      "tags": {
        "smartdc_role": "assets",
        "smartdc_type": "core"
      },
      "snapshots": [
        {
          "name": "zones/ef375f03-57ca-44a9-bc8d-63aec09fbc37@backup"
        }
      ],
    }

There is only one situation when the API can return an 'augmented' VM object and this is when we are requesting a KVM VM (brand == kvm) object. In this case the response JSON in question will have three additional attributes: cpu_type, vcpus and disks. The following example illustrates a sample KVM VM response object:

    {
      "uuid": "03750e6a-fcf6-4755-85b5-22b8ddf0f1fb",
      "brand": "kvm",
      "image_uuid": "56108678-1183-11e1-83c3-ff3185a5b47f",
      "server_uuid": "564d47c4-b845-113b-664f-2a1d85d0020c",
      "billing_id": "00000000-0000-0000-0000-000000000000",
      "package_name": null,
      "package_version": null,
      "alias": null,
      "ram": 256,
      "max_physical_memory": 512,
      "max_swap": 512,
      "quota": null,
      "cpu_cap": null,
      "cpu_shares": 2,
      "max_lwps": 2000,
      "create_timestamp": "2012-12-21T06:55:27.654Z",
      "destroyed": null,
      "last_modified": "2012-12-21T06:55:32.000Z",
      "zone_state": "running",
      "state": "running",
      "zpool": null,
      "zfs_io_priority": 100,
      "owner_uuid": "00000000-0000-0000-0000-000000000000",
      "nics": [
        {
          "interface": "net0",
          "mac": "90:b8:d0:88:45:a8",
          "vlan_id": 0,
          "nic_tag": "admin",
          "gateway": "10.99.99.7",
          "primary": true,
          "ip": "10.99.99.32",
          "netmask": "255.255.255.0",
          "model": "virtio"
        }
      ],
      "resolvers": [
        "10.99.99.11"
      ],
      "snapshots": [],
      "customer_metadata": {},
      "internal_metadata": {},
      "tags": {},
      "vcpus": 1,
      "cpu_type": "host",
      "disks": [
        {
          "path": "/dev/zvol/rdsk/zones/03750e6a-fcf6-4755-85b5-22b8ddf0f1fb-disk0",
          "boot": false,
          "model": "virtio",
          "media": "disk",
          "image_size": 10240,
          "image_uuid": "56108678-1183-11e1-83c3-ff3185a5b47f",
          "image_name": "ubuntu10.04",
          "zfs_filesystem": "zones/03750e6a-fcf6-4755-85b5-22b8ddf0f1fb-disk0",
          "zpool": "zones",
          "size": 5120,
          "compression": "off",
          "block_size": 8192
        },
        {
          "path": "/dev/zvol/rdsk/zones/03750e6a-fcf6-4755-85b5-22b8ddf0f1fb-disk1",
          "boot": false,
          "model": "virtio",
          "media": "disk",
          "size": 10240,
          "zfs_filesystem": "zones/03750e6a-fcf6-4755-85b5-22b8ddf0f1fb-disk1",
          "zpool": "zones",
          "compression": "off",
          "block_size": 8192
        }
      ]
    }

## VM States

The VM response object contains a state attribute that should be used as the high level representation of the machine state. There are three 'running state' values for a VM, two 'provisioning state' values and an additional 'active' state that is only available as a search filter when used in the ListVms API endpoint:

|| **VM State** || **Description** ||
|| running || Self-explanatory ||
|| stopped || Self-explanatory ||
|| destroyed || Self-explanatory||
|| provisioning || VM is currently being provisioned in the system ||
|| failed || VM provisioning has failed ||
|| active || When used in ListVms, denotes machines that are not destroyed ||

In addition, there is a 'zone_state' property that represents the Solaris Zones state, since every VM is really a zone internally. The state property should be used in favor of zone_state at all times, but zone_state is provided in case it's needed for debugging purposes. The following is a table that shows all the possible zone_state values:

|| **Zone State** ||
|| configured ||
|| incomplete ||
|| installed ||
|| ready ||
|| running ||
|| shutting down ||


# VM Job Response Object

Any action called on the VMs or Metadata endpoints will result on a new Job being created on the backend. Performing an action on VM doens't imply that changes are going to be reflected immediately, so a Job response object will provide the user with the necessary info to get more details about progress of the task that has been queued. The user can poll the GET /jobs/<uuid> endpoint for more details and also GET /vms/<uuid> to see if the VM properties have changed after the job completes.

    {
      "vm_uuid": "ef375f03-57ca-44a9-bc8d-63aec09fbc37",
      "job_uuid": "6ad3a288-31cf-44e0-8d18-9b3f2a031067"
    }


# Error Response Object

Error responses will be returned when the response status code is one of 40X errors including 404. These responses will have an error code and a message:

    {
      "code": "ResourceNotFound",
      "message": "Route does not exist"
    }


# Ping VMAPI

Use ping when you want a general status report from VMAPI. VMAPI makes HTTP connections to REST APIs and TCP connections to services like the heartbeat cache and moray. In addition to service status, one might need to know when was the last time that VMAPI saw an incoming heartbeat when debugging VM data propagation errors. The **ping**  endpoint provides a compact response object that lets clients know what is VMAPI's point of view of the backend services it is connected to. The following is the format of the ping response object. The pingErrors attribute is an object where each of its keys is the name of an API (cache, wfapi, moray, cnapi or napi) and the value of each key is the error response that was obtained after pinging the correspondent service.

## Ping (GET /ping)

    GET /ping

    {
      "pid": 12456,
      "status": "OK",
      "healthy": true,
      "services": {
        "cache": "online",
        "wfapi": "online",
        "moray": "online",
        "cnapi": "online",
        "napi": "online"
      },
      "pingErrors": {},
      "lastHeartbeatReceived": {
        "timestamp": "2012-11-22T00:27:49.851Z",
        "server": "564dcf02-3ed9-7459-bdfc-a2884558951f"
      },
      "lastHeartbeatProcessed": {
        "timestamp": "2012-11-22T00:26:59.402Z",
        "server": "564dcf02-3ed9-7459-bdfc-a2884558951f",
        "uuid": "32389211-62c7-4e29-a44c-b24ece8b3946"
      }
    }

Of special note is the **status** attribute that lets us know if VMAPI is fully
functional in terms of data and services initialized. Although a "healthy: true"
value from the ping response means that VMAPI has not had HTTP or backend
initialization errors, it doesn't specify if VMAPI is already processing heartbeats
and populating its internal database correctly. This is mostly an application
condition where VMAPI gets installed on a new SDC7 headnode and there is a
window of time before data from active VMs in the datacenter starts to propagate.
When VMAPI is corretly receving and processing heartbeats then its status is
going to be "OK".


# VMs

The Vms endpoint let us get information about VMs living on a SDC install, there is only one VMAPI instance per datacenter. VMAPI acts as an HTTP interface to VM data stored UFDS. VMAPI is used when need to obtain information about particular VMs or when we need perform actions on them such as start, reboot, resize, etc.

## ListVms (GET /vms)

Returns a list of VMs according the specified search filter.

### Inputs

All inputs are optional.

||**Param**||**Type**||**Description**||
||owner_uuid||UUID||VM Owner||
||server_uuid||UUID||Server where the VM lives||
||image_uuid||UUID||Image of the VM||
||billing_uuid||UUID||UUID of the package the VM was created with||
||brand||String|| Brand of the VM (joyent, joyent-minimal or kvm)||
||alias||String||VM Alias||
||state||String||running, stopped, active or destroyed||
||ram||Number||Amount of memory of the VM||
||create_timestamp||Unix Time in milliseconds or UTC ISO Date String||VM creation timestamp||
||package_name||String||Package name with which the VM was created||
||package_version||String||Package version with which the VM was created||
||tag.key||String||VM tags, see below||

### Collection Size Control Inputs

ListVms also allows controlling the size of the resulting collection with the
use of the sort, limit and offset parameters. These three parameters can be used
on either the regular or the LDAP query version of the ListVms endpoint.

||**Param**||**Type**||**Description**||
||sort||String||Sort by any of the ListVms inputs (except tags).||
||sort.order||String||Order direction. See below||
||limit||Number||Return only the given number of VMs||
||offset||Number||Limit the collection starting from the given offset||

The *sort* direction can be 'asc' (ascending) or 'desc' (descending), and it is
'desc' by default. The following are some examples of valid values for the *sort*
parameter:

    sort=uuid (results in 'uuid DESC')
    sort=alias.desc (results in 'uuid DESC')
    sort=alias.asc (results in 'uuid ASC')

## Tags

VMs can also be searched by tags. Tags are key/value pairs that let us identify a vm by client-specific criteria. If a VM is tagged as 'role=master', then the search filter to be added to the request params should be 'tag.role=master'. When a tag value is '*', the search is performed for VMs that are tagged with any value of the specified key. Any number of tags can be specified. See the examples section for sample searches of VMs by tags.

### Responses

||**Code**||**Description**||**Response**||
||200||||Array of VM objects||

### Examples

    GET /vms
    GET /vms?alias=my-vm
    GET /vms?state=running
    GET /vms?tag.role=sdc
    GET /vms?tag.role=sdc&tag.type=database
    GET /vms?tag.role=*


## ListVms With Search Query (GET /vms)

There is also an advanced feature in the VMs endpoint where you can execute an LDAP compatible search filter if you want a more precise object search. However you need to consider that the same rules regarding searchable attributes apply to this endpoint, so any search on an non-indexed column will return an error. All the searchable attributes listed in the Inputs table above for the ListVms endpoint can be used, with the exception of create_timestamp where only
its Unix time form can be passed. Additionally, there is a very special format you need to respect if you want to search VMs by tags. More on this below.

## Executing LDAP Search Queries

In order to execute a search query against the /vms endpoint, you need to pass a string parameter called query. The string must have the form of a valid LDAP search filter or else you will get an error. Here are some usage examples of this feature:

    GET /vms?query=(alias=adminui*)
    GET /vms?query=(ram>=1024)
    GET /vms?query=(%26(ram<=256)(alias=adminui*)
    GET /vms?query=(%26(ram=512)(alias=adminui0))

Note how the '&' character is escaped as '%26' since the query must be URL encoded. The only exception in the searchable attributes are tags. Since tags have a special format in the database, they have a different but straightforward format for the search filter. Below is an example of searching VMs with a specific tag by using a logical OR:

    GET /vms?query=(|(tags=*-smartdc_type=core-*)(ram>=1024))

As we can see, all we need to do is to enclose the key=value format of tag by the '\*-'' and '-\*'' characters. These are some examples of how to convert tags into a search expression for VMAPI:

|| **Tag Key** || **Tag Value** || **Tag String** || **Search Expression** ||
|| role || dns || role=dns || tags=\*-role=dns-\* ||
|| priority || high || priority=high || tags=\*-priority=high-\* ||
|| purpose || db || purpose=db || tags=\*-purpose=db-\* ||



## GetVm (GET /vms/:uuid)

Returns a VM with the specified UUID. When sync=true is passed, VMAPI will directly load VM details with a synchronous call to CNAPI. This will also refresh the VMs cache so that if a VM was already destroyed and it doesn't appear to be, it will be marked as such in the process. Using the sync version of this action can be seen as 'force VMAPI' to load the VM information directly from CNAPI.

### Inputs

||**Param**||**Type**||**Description**||**Required?**||
||uuid||UUID||VM UUID||Yes||
||owner_uuid||UUID||VM Owner||No||
||sync||Boolean||Load VM info from CNAPI||No||

### Responses

||**Code**||**Description**||**Response**||
||200||||VM object||
||404||VM not found||Error object||

### Example

    GET /vms/00956725-4689-4e2c-9d25-f2172f496f9c


## CreateVm (POST /vms)

Queues a VM provision. This will validate all parameters and create a new job on workflow API when the request is considered to be valid. The response is
the same as a GET to /vms/:uuid, however some VM attributes might not be present since it has not been provisioned yet. The response also contains a Job-Location header which can be used to get more information about the provisioning job that is being executed by workflow API.

### Minimum Required Inputs

||**Param**||**Type**||**Description**||
||owner_uuid||UUID||VM Owner||
||networks*||Array*||List of networks. See 'Specifying Networks for a VM' below.||
||brand||String||'joyent', 'joyent-minimal' or 'kvm'||
||ram*||Number||VM RAM. Not required if billing_id is present||
||billing_id*||UUID||SDC Package UUID. Not required if at least ram is present. See 'Provisioning with an SDC Package' below.||

### Required Inputs for OS VMs

||**Param**||**Type**||**Description**||
||image_uuid||UUID||Image UUID. **This field is not allowed as a top level attribute for a KVM VM payload, see below**||

### Required Inputs for KVM VMs

||**Param**||**Type**||**Description**||
||disks||Array||Disks definition for the KVM VM, see below||

KVM VMs need a list of disks as an additional parameter. For more specific information on the full format that a disk object can take please refer to vmadm(1). In the case of VMAPI, there are only two conditions that need to be met for a valid disks list:

* The first disk MUST have a 'image_uuid' property. This is required because the first disk of the VM is the disk where the OS gets installed. Passing 'image_uuid' at the top level of the VM payload ***is not allowed*** as it will not give the expected results.

When image_uuid is passed incorrectly for KVM VMs, VMAPI will return the following error response:


      {
        "code": "ValidationFailed",
        "message": "Invalid VM parameters",
        "errors": [
          {
            "field": "image_uuid",
            "code": "Invalid",
            "message": "'image_uuid' is not allowed as a top level attribute for a KVM VM"
          }
        ]
      }


* The second and following disks in the list MUST have a 'size' property. This is mandatory for any disk that is not the image disk of the VM

The following is a simple example of a valid disks list passed to VMAPI for a KVM VM provision:

    "disks": [
      {"image_uuid": "56108678-1183-11e1-83c3-ff3185a5b47f"},
      {"size": 10240}
    ]

Additional information that the first disk of the VM needs before the provision is queued is obtained from the Image specified with image_uuid.

### Specifying Networks for a VM

CreateVm expects a list of `networks` for provisioning a new VM. In its legacy interface (to be deprecated), a list network UUIDs can be specified like the following example:

    [
      '72a9cd7d-2a0d-4f45-8fa5-f092a3654ce2',
      '01b2c898-945f-11e1-a523-af1afbe22822
    ]

This format is suboptimal because it does not allow to specify two additional properties available for each of the network interfaces of the VM. By passing a list of network objects and not a list of UUIDs (strings) for the `networks` parameter, it is possible to manually assign an IP address to any of the networks and/or to specify which is the `primary` network interface of the VM. Let's take a look at some examples.

* Regular provision with no customization for networks

*Network objects only have a `uuid` property:*

    [
      { uuid: '72a9cd7d-2a0d-4f45-8fa5-f092a3654ce2' },
      { uuid: '01b2c898-945f-11e1-a523-af1afbe22822' }
    ]

* Specifying a custom IP address for any of the networks

*Network objects can have an `ip` property. Be advised that manual IP addresses must not be specified without having knowledge of the IP in question
being available for allocation:*

    [
      { uuid: '72a9cd7d-2a0d-4f45-8fa5-f092a3654ce2', ip: '10.99.99.11' },
      { uuid: '01b2c898-945f-11e1-a523-af1afbe22822 }
    ]

* Specifying the primary network for a VM

*Network objects can **only** have a `primary` network interface (NIC). When not specified, the first network in the `networks` list becomes the primary NIC for the VM. A VM will set its default gateway and nameservers to the values obtained from its primary NIC. In the following example we make the second NIC of the VM its primary NIC:*

    [
      { uuid: '72a9cd7d-2a0d-4f45-8fa5-f092a3654ce2' },
      { uuid: '01b2c898-945f-11e1-a523-af1afbe22822', 'primary': true }
    ]

* Specifying network names instead of network UUIDs

*It is also possible to use a network's name instead of its UUID when passing the list of `networks` for the VM. The following example illustrates how to specify a payload of admin and external with external as a primary NIC:*

    [
      { name: 'admin' },
      { name: 'external', primary: true }
    ]

It should be noted that the order of the network objects in the `networks` parameter is significant. The resolvers of a VM will be configured in the same order as the `networks` were specified in the provision payload.


### Provisioning with an SDC Package

VMs can optionally be provisioned by only providing a 'billing_id' SDC Package identifier. When providing an SDC Package, the following VM attributes can be omitted since they will be inherited from the Package definition:

||**Param**||**Type**||
||cpu_cap||Number||
||max_lwps||Number||
||max_physical_memory||Number (MiB)||
||max_swap||Number (MiB)||
||quota||Number (GiB)||VM quota||
||zfs_io_priority||Number||
||vcpus||Number||

However, these values can still be individualy overriden by providing new values for them in the VM provisionm payload. Note that for the purpose of having a 1:1 VM - SDC Package correspondence it is advised that individual values should not be overriden when it is needed to refer a VM back to its original SDC Package.

### General Optional Inputs

These inputs can be passed and will be validated wether or not a 'billing_id' SDC Package parameter has been provided.

||**Param**||**Type**||**Description**||
||server_uuid||UUID||Manually specify a server for the provision||
||alias||String||VM alias||
||max_physical_memory||Number (MiB)||Same as RAM||
||max_swap||Number (MiB)||Defaults to 2 x RAM if not specified||
||zfs_io_priority||Number||ZFS IO Priority||
||cpu_cap||Number||CPU Cap||
||max_lwps||Number||Max. Lightweight Processes||
||quota||Number (GiB)||VM quota||
||tags||Object||VM tags||
||customer_metadata||Object||VM metadata||
||internal_metadata||Object||VM metadata||
||limit_priv||String||List of priviledges to the VM||

### Optional Inputs for OS VMs

||**Param**||**Type**||**Description**||
||filesystems||Array||Additional filesystems for the OS VM||

### Optional Inputs for KVM VMs

||**Param**||**Type**||**Description**||
||cpu_type||String||One of qemu64, host||
||vcpus||Number||Number of virtual CPUs for the guest||
||disk_driver||String||One of virtio, ide, scsi||
||nic_driver||String||One of virtio, e1000, rtl8139||


### Response Codes

||**Code**||**Description**||**Response**||
||202||New job created||VM response object||
||409||Missing parameter||Error object||
||409||Invalid parameter||Error object||

### Example: creating an OS VM

    POST /vms -d '{
      "owner_uuid": "930896af-bf8c-48d4-885c-6573a94b1853",
      "image_uuid": "28445220-6eac-11e1-9ce8-5f14ed22e782",
      "brand": "joyent",
      "networks": ["a4457fc9-c415-4ac9-8738-a03b1a8e7aee"],
      "ram": 128,
      "quota": 10
    }'

### Example: creating an OS VM by specifying an SDC Package

    POST /vms -d '{
      "owner_uuid": "930896af-bf8c-48d4-885c-6573a94b1853",
      "image_uuid": "28445220-6eac-11e1-9ce8-5f14ed22e782",
      "brand": "joyent",
      "networks": ["a4457fc9-c415-4ac9-8738-a03b1a8e7aee"],
      "billing_id":"0ea54d9d-8d4d-4959-a87e-bf47c0f61a47"
    }'

### Example: creating a KVM VM

Note how image_uuid is specified for the first disk and not at the top level of the payload

    POST /vms -d '{
      "owner_uuid": "930896af-bf8c-48d4-885c-6573a94b1853",
      "brand": "kvm",
      "ram": 256,
      "networks": ["a4457fc9-c415-4ac9-8738-a03b1a8e7aee"],
      "disks": [
        {"image_uuid": "56108678-1183-11e1-83c3-ff3185a5b47f"},
        {"size": 10240}
      ]
    }'


## Updating or Modifying a VM (POST /vms/:uuid)

This endpoint queues an update operation on a VM. The folowing operations are
supported: **start, stop, reboot, reprovision, update, add_nics, remove_nics,
create_snapshot, delete_snapshot and rollback_snapshot**. Each of these
operations is documented below.

### General Inputs

||**Param**||**Type**||**Description**||**Required?**||
||uuid||UUID||VM UUID||Yes||
||owner_uuid||UUID||VM Owner||No||
||action||String||start, stop, reboot, reprovision, update, add_nics, remove_nics, create_snapshot, delete_snapshot, rollback_snapshot||Yes||

### Response Codes

||**Code**||**Description**||**Response**||
||202||New job created||VM response object||
||404||VM not found||Error object||
||409||Missing parameter||Error object||
||409||Invalid parameter||Error object||

## StartVm (POST /vms/:uuid?action=start)

No additional inputs are needed for this action.

### Example

    POST /vms/e9bd0ed1-7de3-4c66-a649-d675dbce6e83?action=start

## StopVm (POST /vms/:uuid?action=stop)

No additional inputs are needed for this action.

### Example

    POST /vms/e9bd0ed1-7de3-4c66-a649-d675dbce6e83?action=stop

## RebootVm (POST /vms/:uuid?action=reboot)

No additional inputs are needed for this action.

### Example

    POST /vms/e9bd0ed1-7de3-4c66-a649-d675dbce6e83?action=reboot

## ReprovisionVm (POST /vms/:uuid?action=reprovision)

Image UUID is a required input for reprovisioning a VM.

||**Param**||**Type**||**Description**||
||image_uuid||UUID||Image UUID to reprovision the VM with||

### Example with a JSON payload

    POST /vms/e9bd0ed1-7de3-4c66-a649-d675dbce6e83?action=rollback_snapshot -d \
    '{ "image_uuid": "01b2c898-945f-11e1-a523-af1afbe22822" }'

### Example with form parameters

    POST /vms/e9bd0ed1-7de3-4c66-a649-d675dbce6e83?action=rollback_snapshot \
      -d image_uuid=01b2c898-945f-11e1-a523-af1afbe22822

## UpdateVm (POST /vms/:uuid?action=update)

Similar to CreateVm, this endpoint allows udpating a VM to a new SDC Package. Individual SDC Package related attributes can still be provided if one needs to override specific values.

### Updating VM to an SDC Package

||**Param**||**Type**||**Description**||
||billing_id||UUID||SDC Package UUID||

The UpdateVm payload would automatically retrieve the following values from the provided SDC Package:

||**Param**||**Type**||
||cpu_cap||Number||
||max_lwps||Number||
||max_physical_memory||Number (MiB)||
||max_swap||Number (MiB)||
||quota||Number (GiB)||VM quota||
||zfs_io_priority||Number||
||vcpus||Number||

### Updating a VM With Individual VM Values

In addition to 'billing_id', the following values can be specified to update additional attributes of the VM.

||**Param**||**Type**||**Description**||
||alias||String||VM alias||
||new_owner_uuid||UUID||UUID of the new VM Owner||
||ram||Number||VM RAM||
||max_physical_memory (MiB)||Number||Same as RAM||
||max_swap (MiB)||Number||Defaults to 2 x RAM if not specified||
||zfs_io_priority||Number||ZFS IO Priority||
||cpu_cap||Number||CPU Cap||
||max_lwps||Number||Max. Lightweight Processes||
||quota (GiB)||Number||VM quota (disk)||
||tags||Object||VM tags||
||customer_metadata||Object||VM metadata||
||internal_metadata||Object||VM metadata||
||resolvers||Array||New set of resolvers for the VM||
||limit_priv||String||List of priviledges to the VM||
||fs_allowed||String (Comma separated list)||Filesystem types that the VM is allowed to mount||

### Example: Renaming a VM and updating its quota

    POST /vms/e9bd0ed1-7de3-4c66-a649-d675dbce6e83?action=update -d '{
        "alias": "new-alias",
        "quota": 20
    }'

### Example: Updating a VM to a new SDC Package

    POST /vms/e9bd0ed1-7de3-4c66-a649-d675dbce6e83?action=update -d '{
        "billing_id": "73a1ca34-1e30-48c7-8681-70314a9c67d3"
    }'

## AddNics (POST /vms/:uuid?action=add_nics)

For adding NICs to a VM, a `networks` list parameter must be specified. For more information about the format of `networks`, see 'Specifying Networks for a VM' in the CreateVM documentation.

||**Param**||**Type**||**Description**||
||networks*||Array*||List of networks. Same format as CreateVm||

### Example with a JSON payload

    POST /vms/e9bd0ed1-7de3-4c66-a649-d675dbce6e83?action=add_nics -d '{
      "networks": [ { "uuid": "564ded48-c31d-5029-472a-98d5aa9e5a38" } ]
    }'

### Example with form parameters

    POST /vms/e9bd0ed1-7de3-4c66-a649-d675dbce6e83?action=add_nics \
      -d networks=564ded48-c31d-5029-472a-98d5aa9e5a38 \

## UpdateNics (POST /vms/:uuid?action=update_nics)

Updates NICs for a VM. Currently, these action only serves two purposes: setting a new primary NIC for a VM and/or reordering its NICs. Each NIC object can only contain three properties:

||**Attribute**||**Type**||**Description**||
||mac||MAC Address||NIC MAC Address||
||interface||String||NIC interface/order identifier||
||primary||Boolean||Primary NIC flag||

For the UpdateNics action, a list of at least one NIC object must be specified. If the purpose of the request is to set a new primary NIC, then only one NIC object can have the `primary` attribute set. If the purpose of the request is to reorder the VM NICs, then every NIC object must have its `interface` attribute set and the number of NICs in the array must be the same as the number of NICs the VM currently has. The following table describes the only allowed input for UpdateNics:

||**Param**||**Type**||**Description**||
||nics||Array||List of NIC objects. See above||

### Example: setting a new primary NIC

    POST /vms/0cb0f7b1-b092-4252-b205-c9c268bfa148?action=update_nics -d '{
      "nics":[{
        "mac": "90:b8:d0:d4:02:f5",
        "primary": true
      }]
    }'

### Example: reordering the VM NICs

    POST /vms/0cb0f7b1-b092-4252-b205-c9c268bfa148?action=update_nics -d '{
      "nics":[{
        "mac": "90:b8:d0:43:56:ba",
        "interface": "net0"
      },{
        "mac": "90:b8:d0:d4:02:f5",
        "interface": "net1"
      }]
    }'


## RemoveNics (POST /vms/:uuid?action=remove_nics)

For removing NICs from a VM, a macs list parameter must be specified. This parameter can be an array of MAC addresses or a comma separated string of MAC addresses.

||**Param**||**Type**||**Description**||
||macs||Array||List of MAC addresses||

### Example with a JSON payload

    POST /vms/e9bd0ed1-7de3-4c66-a649-d675dbce6e83?action=remove_nics -d '{
      "macs": [ "90:b8:d0:d9:f0:83" ]
    }'

### Example with form parameters

    POST /vms/e9bd0ed1-7de3-4c66-a649-d675dbce6e83?action=remove_nics \
      -d macs=90:b8:d0:d9:f0:83 \


## CreateSnapshot (POST /vms/:uuid?action=create_snapshot)

If a name for the snapshot is not specified, VMAPI will generate a timestamp for its name with the UTC ISO date/time format (without colons or dashes):

    YYYYMMDDTHHMMSSZ

    Example:

    20121018T222506Z

||**Param**||**Type**||**Description**||
||snapshot_name||String||Snapshot name or generated timestamp if not present||

### Example with a JSON payload

    POST /vms/e9bd0ed1-7de3-4c66-a649-d675dbce6e83?action=create_snapshot -d \
    '{ "snapshot_name": "foobar" }'

### Example with form parameters

    POST /vms/e9bd0ed1-7de3-4c66-a649-d675dbce6e83?action=create_snapshot \
      -d snapshot_name=foobar


## DeleteSnapshot (POST /vms/:uuid?action=delete_snapshot)

||**Param**||**Type**||**Description**||
||snapshot_name||String||Snapshot name||

### Example with a JSON payload

    POST /vms/e9bd0ed1-7de3-4c66-a649-d675dbce6e83?action=delete_snapshot -d \
    '{ "snapshot_name": "foobar" }'

### Example with form parameters

    POST /vms/e9bd0ed1-7de3-4c66-a649-d675dbce6e83?action=delete_snapshot \
      -d snapshot_name=foobar


## RollbackSnapshot (POST /vms/:uuid?action=rollback_snapshot)

If the VM is running at the moment of the request, it will be
shutdown before executing the rollback and be booted again after the rollback
has succeeded.

||**Param**||**Type**||**Description**||
||snapshot_name||String||Snapshot name||

### Example with a JSON payload

    POST /vms/e9bd0ed1-7de3-4c66-a649-d675dbce6e83?action=rollback_snapshot -d \
    '{ "snapshot_name": "foobar" }'

### Example with form parameters

    POST /vms/e9bd0ed1-7de3-4c66-a649-d675dbce6e83?action=rollback_snapshot \
      -d snapshot_name=foobar



## DeleteVm (DELETE /vms/:uuid)

Deletes a VM. The VM will be physically destroyed and it will be marked as destroyed
in the cache database.

### Inputs

||**Param**||**Type**||**Description**||**Required?**||
||uuid||UUID||VM UUID||Yes||
||owner_uuid||UUID||VM Owner||No||

### Responses

||**Code**||**Description**||**Response**||
||202||New job created||VM response object||
||404||VM not found||Error object||
||409||VM not allocated to a server yet||Error object||


### Example

    DELETE /vms/e9bd0ed1-7de3-4c66-a649-d675dbce6e83


# VM Metadata

There are three kinds of metadata a VM can store: customer_metadata, internal_metadata and tags. A metadata object is any valid set of key/value pairs that can be properly encoded to JSON. Values must be strings, numbers or booleans. Examples:

    {
      "ip": "10.99.99.9",
      "boolean": true,
      "string": "foobar",
      "number": 42
    }

VM Tags allow VMs to be grouped by any criteria. Tags are key/value pairs that can be assigned to any VM. For example, VMs can be grouped by tagging them as a database role with a tag such as '{ role: "database" }'.

Customer and internal metadata are used to store relevant information to the VM, such as IP addresses of dependent VMs or initialization scripts that run when the VM is being setup.

The following API endpoints are equivalent for tags, customer_metadata and internal_metadata since all three metadata types share the same representation.


## ListMetadata (GET /vms/:uuid/(tags|customer_metadata|internal_metadata))

Returns metadata assigned to a VM.

### Inputs

||**Param**||**Type**||**Description**||**Required?**||
||uuid||UUID||VM UUID||Yes||
||owner_uuid||UUID||VM Owner||No||

### Responses

||**Code**||**Description**||**Response**||
||200||||Metadata object||
||404||VM not found||Error object||

### Example

    GET /vms/da0dfac1-341e-4e51-b357-99f7355f1008/tags

    {
      "role": "dns",
      "customer": "tracy"
    }


## GetMetadata (GET /vms/:uuid/(tags|customer_metadata|internal_metadata)/:key)

Returns the value of a metadata key.

### Inputs

||**Param**||**Type**||**Description**||**Required?**||
||uuid||UUID||VM UUID||Yes||
||owner_uuid||UUID||VM Owner||No||
||key||String||Metadata Key||Yes||

### Responses

||**Code**||**Description**||**Response**||
||200||||String value of the metadata key||
||404||VM not found||Error object||

### Example

    GET /vms/da0dfac1-341e-4e51-b357-99f7355f1008/tags/role

    dns


## AddMetadata (POST /vms/:uuid/(tags|customer_metadata|internal_metadata))

Adds a new metadata to a VM. Keep in mind that metadata gets appended, not overwritten.

### Inputs

||**Param**||**Type**||**Description**||**Required?**||
||uuid||UUID||VM UUID||Yes||
||owner_uuid||UUID||VM Owner||No||
||metadata||key-value/object||Metadata||Yes||

### Responses

||**Code**||**Description**||**Response**||
||202||New job created||VM response object||
||404||VM not found||Error object||

### Example

    POST /vms/da0dfac1-341e-4e51-b357-99f7355f1008/tags
      -d customer=tracy
    POST /vms/da0dfac1-341e-4e51-b357-99f7355f1008/tags
      --data-binary '{ "customer": "tracy" }'


## SetMetadata (PUT /vms/:uuid/(tags|customer_metadata|internal_metadata))

Sets new metadata to a VM. The provided metadata object replaces the current
one present in the VM.

### Inputs

||**Param**||**Type**||**Description**||**Required?**||
||uuid||UUID||VM UUID||Yes||
||owner_uuid||UUID||VM Owner||No||
||metadata||key-value/object||Metadata||Yes||

### Responses

||**Code**||**Description**||**Response**||
||202||New job created||VM response object||
||404||VM not found||Error object||

### Example

    PUT /vms/da0dfac1-341e-4e51-b357-99f7355f1008/tags
      -d customer=tracy
    PUT /vms/da0dfac1-341e-4e51-b357-99f7355f1008/tags
      --data-binary '{ "customer": "tracy" }'


## DeleteMetadata (DELETE /vms/:uuid/(tags|customer_metadata|internal_metadata)/:key)

Deletes a metadata key from a VM.

### Inputs

||**Param**||**Type**||**Description**||**Required?**||
||uuid||UUID||VM UUID||Yes||
||owner_uuid||UUID||VM Owner||No||
||key||String||Metadata Key||Yes||

### Responses

||**Code**||**Description**||**Response**||
||202||New job created||VM response object||
||404||VM not found||Error object||

### Example

    DELETE /vms/da0dfac1-341e-4e51-b357-99f7355f1008/tags/role


## DeleteAllMetadata (DELETE /vms/:uuid/(tags|customer_metadata|internal_metadata))

Deletes all metadata keys from a VM.

### Inputs

||**Param**||**Type**||**Description**||**Required?**||
||uuid||UUID||VM UUID||Yes||
||owner_uuid||UUID||VM Owner||No||

### Responses

||**Code**||**Description**||**Response**||
||202||New job created||VM response object||
||404||VM not found||Error object||

### Example

    DELETE /vms/da0dfac1-341e-4e51-b357-99f7355f1008/tags


# Jobs

Jobs are created when an operation needs to be performed on a VM. Examples of jobs that can be created are VM lifecycle tasks such as start and reboot. Provision jobs are created from calling "POST /vms".


## ListJobs (GET /jobs)

Returns all jobs matching the specified search filters.

### Inputs

|| **Param** || **Type** || **Description** || **Required?** ||
|| vm_uuid || UUID || Return all jobs for this VM UUID || No ||
|| execution || String || Job state. See below || No ||
|| task || String || Type of job. See below || No ||

### Job 'execution' State Inputs

|| **Execution** ||
|| running ||
|| succeeded ||
|| failed ||

### Job 'task' Type Inputs

**NOTE** Any metadata endpoint that returns a Job response object is an 'update'
job for the backend system.

|| **Task** ||
|| provision ||
|| start ||
|| stop ||
|| reboot ||
|| update ||

### Example

    GET /jobs?execution=failed
    GET /jobs?task=provision


## ListVmJobs (GET /vms/:uuid/jobs)

Returns all VM jobs matching the specified search filters. This is the same
implementation as the previous endpoint, but with a more convenient path when
the VM UUID is known.

### Inputs

|| **Param** || **Type** || **Description** || **Required?** ||
|| uuid || UUID || Return all jobs for this VM UUID || No ||
|| execution || String || Job state. See above || No ||
|| task || String || Type of job. See above || No ||

### Example

    GET /vms/da0dfac1-341e-4e51-b357-99f7355f1008/jobs?execution=failed
    GET /vms/da0dfac1-341e-4e51-b357-99f7355f1008/jobs?task=provision


## GetJob (GET /jobs/:uuid)

Returns a job with the specified UUID.

### Inputs

||**Param**||**Type**||**Description**||**Required?**||
||uuid||UUID||Job UUID||Yes||

### Example

    GET /jobs/6ad3a288-31cf-44e0-8d18-9b3f2a031067

    {
      "name": "provision-4e4ff04b-5cc4-437e-92da-2403a634e74f",
      "uuid": "6ad3a288-31cf-44e0-8d18-9b3f2a031067",
      "execution": "succeeded",
      "params": {
        "owner_uuid": "930896af-bf8c-48d4-885c-6573a94b1853",
        "image_uuid": "28445220-6eac-11e1-9ce8-5f14ed22e782",
        "brand": "joyent",
        "ram": "128",
        "zonename": "e9bd0ed1-7de3-4c66-a649-d675dbce6e83",
        "uuid": "e9bd0ed1-7de3-4c66-a649-d675dbce6e83",
        "server_uuid": "564da914-5047-48f0-ba5e-26761097330a",
        "task": {
          "id": "70129767",
          "progress": 100,
          "status": "complete"
        }
      },
      "exec_after": "2012-04-13T18:17:15.194Z",
      "created_at": "2012-04-13T18:17:15.198Z",
      "timeout": 180,
      "chain_results": [
        {
          "result": "All parameters OK!",
          "error": "",
          "started_at": "2012-04-13T18:17:17.512Z",
          "finished_at": "2012-04-13T18:17:18.619Z"
        },
        {
          "result": "Got servers!",
          "error": "",
          "started_at": "2012-04-13T18:17:18.628Z",
          "finished_at": "2012-04-13T18:17:21.737Z"
        },
        {
          "result": "Server allocated!",
          "error": "",
          "started_at": "2012-04-13T18:17:21.743Z",
          "finished_at": "2012-04-13T18:17:23.137Z"
        },
        {
          "result": "Provision succeeded!",
          "error": "",
          "started_at": "2012-04-13T18:17:23.197Z",
          "finished_at": "2012-04-13T18:18:42.726Z"
        }
      ]
    }


# Running Status for VMs

When querying one of the VM endpoints such as the single and collection VM URLs, the 'state' attribute of the VM object let us know what is the running status of the machine. In addition to this, a '/statuses' endpoint is provided to give information about specific VM UUIDs instead of returning VM objects for machines that satisfy a search criteria.

## ListStatuses (GET /statuses)

Returns the running status for all of the VM UUIDs specified in the request parameters.

### Inputs

|| **Param** || **Type** || **Description** || **Required?** ||
|| uuids || Array of UUIDs || Comma separated list of UUIDs || Yes ||

### Note

When one of the UUIDs in the request parameters corresponds to a machine that does not exist, it is ignored in the response object instead of returning null.

### Example

    GET /statuses?uuids=54e21a72-5921-4c5a-92db-fb662c8a812a,4f11fbab-dcc0-483f-bb14-e1434465032a

    {
      "54e21a72-5921-4c5a-92db-fb662c8a812a": "running",
      "4f11fbab-dcc0-483f-bb14-e1434465032a": "stopped"
    }



# Operator Guide

This section is intended to give necessary information for diagnosing and
dealing with issues with VMAPI in a SmartDataCenter installation.

There is one VMAPI service per datacenter. There might actually be more than
one "vmapi" zone for HA. Use this to list the vmapi zones in a DC:

    sdc-vmapi /vms?owner_uuid=$(bash /lib/sdc/config.sh -json | json ufds_admin_uuid) \
        | json -H -c "tags.smartdc_role=='vmapi'"


## VMAPI Configuration File

By default, VMAPI's configuration file is located at "./config.json". Any value
in the table below that has a default value can be overrided in the configuration
file. Note that this file should only be modified if any other service depending
on VMAPI is updated as well.

||**var**||**type**||**default**||**description**||
||port||Number||80||Port number on which to listen.||
||logLevel||String or Number||debug||Level at which to log. One of the supported Bunyan log levels.||
||heartbeatQueueSize||Number||50||Maximum number of heartbeats to process in parallel.||
||maxSockets||Number||100||Maximum number of sockets for external API calls||
||api||Object||-||VMAPI configuration||
||api||Number||-||VMAPI port||
||amqp.host||String||-||RabbitMQ hostname||
||amqp||Object||-||RabbitMQ credentials||
||amqp.host||String||-||RabbitMQ hostname||
||amqp.queue||String||heartbeat.vmapi||Heartbeater AMQP queue||
||cache||Object||-||Cache client definition||
||cache.type||String||-||Cache type, can be 'redis' or 'moray'||
||cache.host||String||-||Hostname for cache type 'redis'||
||wfapi||Object||-||WFAPI configuration||
||wfapi.url||String||-||WFAPI URL||
||wfapi.forceReplace||Boolean||false||Replace workflows every time VMAPI restarts||
||wfapi.workflows||Array||-||List of workflows to load on start||
||cnapi||Object||-||CNAPI configuration||
||cnapi.url||String||-||CNAPI URL||
||napi||Object||-||NAPI configuration||
||napi.url||String||-||NAPI URL||
||moray||Object||-||Moray configuration||
||moray.host||String||-||Moray hostname||
||moray.port||Number||-||Moray port||
||moray.connectTimeout||Number||-||Moray connection timeout||
||moray.retry||Object||-||Moray retry object||
||moray.retry.minTimeout||Number||-||Moray minimum retry timeout||
||moray.retry.maxTimeout||Number||-||Moray maximum retry timeout||


## Health

As seen in the API actions documentation, VMAPI has a "/ping" endpoint to
indicate if it is up

    $ sdc-vmapi /ping

or if there are multiple VMAPI servers:

    $ for ip in $(bash /lib/sdc/config.sh -json | json vmapi_admin_ips | tr ',' ' '); do \
        echo "# $ip" ; \
        curl -sS http://$ip/ping | json ; \
    done


## Logs

TODO: how to dynamically change log levels

VMAPI is a single SMF service that operates on a SmartOS VM. The following is the
location/command for accessing the log file written by the VMAPI service:

||**service/path**||**where**||**format**||**tail -f**||
||vmapi||in each "vmapi" zone||[Bunyan](https://github.com/trentm/node-bunyan)||`` sdc-login vmapi; tail -f `svcs -L vmapi` | bunyan ``||

Note that the logs for the VMAPI service are rotated, so one might need the
directory where these files are being written in case older log files contain the
information that we are looking for. Use the following command to find the
directory where the VMAPI SMF service writes its files:


## Analysing Logs

VMAPI uses Bunyan as its logging module. This allows users to find useful
debugging information in a very straightforward way since each log message
produced by Bunyan is a JSON object. VMAPI logs are structured so that they can
be filtered by component, API action, VM UUID and Server UUID when using the
`bunyan` command line utility.

The following are the components that describe each of the pieces in the VMAPI
application and allow for more specific log filtering:

|| **Component Name** || **Description** ||
|| api || API requests/responses ||
|| heartbeater || Heartbeater processing activity ||
|| napi || NIC add/removal activity ||
|| cnapi || machine_load requests/responses (used to process heartbeats) ||
|| wfapi || WFAPI requests/responses (for queueing VM jobs) ||
|| moray || Moray database operations (read/write VM data) ||
|| cache || Heartbeat cache client ||

In order to filter a VMAPI log file by component we make use of Bunyan's '-c'
option:

    -c, --condition CONDITION
                  Run each log message through the condition and
                  only show those that return truish. E.g.:
                      -c 'this.pid == 123'
                      -c 'this.level == DEBUG'
                      -c 'this.msg.indexOf("boom") != -1'
                  'CONDITION' must be legal JS code. `this` holds
                  the log record. The TRACE, DEBUG, ... FATAL values
                  are defined to help with comparing `this.level`.

The 'this' variable inside a condition refers to the JSON object that was logged
by Bunyan at any given point in time. If we wanted to see all messages that have
been produced by the heartbeater module we would issue the following command:

    cat tmp/local.log | bunyan -c "this.component === 'heartbeater'"

    [2013-03-12T16:46:21.601Z] DEBUG: vmapi/heartbeater/79487: VM object 0c81af15-d3b2-47f9-a75a-db7f16a65434 updated on moray (vm_uuid=0c81af15-d3b2-47f9-a75a-db7f16a65434)
    [2013-03-12T16:46:21.612Z] DEBUG: vmapi/heartbeater/79487: NICs added for VM 0c81af15-d3b2-47f9-a75a-db7f16a65434 (vm_uuid=0c81af15-d3b2-47f9-a75a-db7f16a65434)
    [2013-03-12T16:46:21.613Z] DEBUG: vmapi/heartbeater/79487: (vm_uuid=0c81af15-d3b2-47f9-a75a-db7f16a65434)
        VM 0c81af15-d3b2-47f9-a75a-db7f16a65434 state cached { uuid: '0c81af15-d3b2-47f9-a75a-db7f16a65434',
          owner_uuid: '00000000-0000-0000-0000-000000000000',
          quota: 10240,
          max_physical_memory: 64,
          zone_state: 'installed',
          state: 'stopped',
          brand: 'joyent-minimal',
          last_modified: '2013-03-12T16:46:14.000Z' }

Bunyan still allows us to filter logs by level, so in case we were looking for
an exception produced while processing heartbeats we can do the following:

    cat tmp/local.log | bunyan -c "this.component === 'heartbeater'" -l error

    [2013-03-12T19:01:37.103Z] ERROR: vmapi/heartbeater/70242: Cannot process heartbeats for Server 564d3d49-9bb1-3726-a1ea-b265db3a7f39 (server=564d3d49-9bb1-3726-a1ea-b265db3a7f39)
        Error: connect ECONNREFUSED
            at errnoException (net.js:770:11)
            at Object.afterConnect [as oncomplete] (net.js:761:19)

### Filtering specific VM activity

In addition to components, logs can be filtered by VM UUID and API action. This
enables operators to better track all the API actions called for a VM of
interest and see if its heartbeats have been processed correctly.

Again, by using the '-c' option in Bunyan, we use the vm_uuid attribute to find
all log entries related to a single VM:

    cat tmp/local.log | bunyan -c "this.vm_uuid === '0c81af15-d3b2-47f9-a75a-db7f16a65434'"

    [2013-03-12T16:46:23.091Z] TRACE: vmapi/api/79487: GetVm start (vm_uuid=0c81af15-d3b2-47f9-a75a-db7f16a65434)
    [2013-03-12T16:46:23.092Z]  INFO: vmapi/api/79487: handled: 200 (vm_uuid=0c81af15-d3b2-47f9-a75a-db7f16a65434, audit=true, remoteAddress=127.0.0.1, remotePort=65466, latency=11, _audit=true, req.body="")
        GET /vms/0c81af15-d3b2-47f9-a75a-db7f16a65434?owner_uuid=00000000-0000-0000-0000-000000000000 HTTP/1.1
        accept: application/json
        user-agent: restify/2.2.2 (x64-darwin; v8/3.11.10.25; OpenSSL/1.0.0f) node/0.8.18
        accept-version: *
        date: Tue, 12 Mar 2013 16:46:23 GMT
        host: localhost:8080
        connection: close
        ...
        ...
    [2013-03-12T16:46:23.105Z] TRACE: vmapi/api/79487: DeleteVm start (vm_uuid=0c81af15-d3b2-47f9-a75a-db7f16a65434)
    [2013-03-12T16:46:30.039Z] TRACE: vmapi/heartbeater/79487: (server=564d3d49-9bb1-3726-a1ea-b265db3a7f39, vm_uuid=0c81af15-d3b2-47f9-a75a-db7f16a65434)
        Heartbeat from 0c81af15-d3b2-47f9-a75a-db7f16a65434: { uuid: '0c81af15-d3b2-47f9-a75a-db7f16a65434',
          owner_uuid: '00000000-0000-0000-0000-000000000000',
          quota: 10240,
          max_physical_memory: 64,
          zone_state: 'installed',
          state: 'stopped',
          brand: 'joyent-minimal',
          last_modified: '2013-03-12T16:46:14.000Z' }
    [2013-03-12T16:46:30.042Z] TRACE: vmapi/heartbeater/79487: Timestamps for VM 0c81af15-d3b2-47f9-a75a-db7f16a65434, oldLastModified: Tue Mar 12 2013 11:46:14 GMT-0500 (COT), lastModified: Tue Mar 12 2013 11:46:14 GMT-0500 (COT) (vm_uuid=0c81af15-d3b2-47f9-a75a-db7f16a65434)

From this example we can see that there are both API and Heartbeater log records
for the VM in question. Going further we could filter this information by adding
an additional component condition:

    cat tmp/local.log | bunyan -c "this.vm_uuid === '0c81af15-d3b2-47f9-a75a-db7f16a65434' && this.component === 'heartbeater'"

Or:

    cat tmp/local.log | bunyan -c "this.vm_uuid === '0c81af15-d3b2-47f9-a75a-db7f16a65434' && this.component === 'api'"

Now, if we wanted to focus our attention on specific API actions for a VM we can
also filter logs by route name. The following is a list of API actions in VMAPI
that can be filtered in the logs. The route name to be used for the Bunyan
utility is just the lower case version of the API action that can be found on
this documentation. Note that some routes accept a vm_uuid parameter when they
are actions specific to a single VM and not a collection of VMs.

|| **API Action** || **Route Name** || **Accepts vm_uuid?**||
|| ListVms || listvms || No ||
|| CreateVm || createvm || No ||
|| GetVm || getvm || Yes ||
|| StartVm || startvm || Yes ||
|| StopVm || stopvm || Yes ||
|| RebootVm || rebootvm || Yes ||
|| ChangeVm || changevm || Yes ||
|| DeleteVm || deletevm || Yes ||
|| AddNics || addnics || Yes ||
|| RemoveNics || removenics || Yes ||
|| CreateSnapshot || createsnapshot || Yes ||
|| RollbackSnapshot || rollbacksnapshot || Yes ||
|| DeleteSnapshot || deletesnapshot || Yes ||
|| ListMetadata || listmetadata || Yes ||
|| GetMetadata || getmetadata || Yes ||
|| AddMetadata || addmetadata || Yes ||
|| SetMetadata || setmetadata || Yes ||
|| DeleteMetadata || deletemetadata || Yes ||
|| DeleteMetadata || deleteallmetadata || Yes ||

As an example, we can run this command to get the logs of all the GetVm calls to
VMAPI:

    cat tmp/local.log | bunyan -c "this.route === 'getvm'"

    [2013-03-13T21:12:00.788Z]  INFO: vmapi/api/91013 on Andres-Rodriguezs-MacBook-Pro.local: handled: 200 (vm_uuid=00b70fd9-731d-4c9c-bf9a-7f859bf6c3cf, route=getvm, audit=true, remoteAddress=127.0.0.1, remotePort=61123, latency=21, _audit=true, req.body="")
        GET /vms/00b70fd9-731d-4c9c-bf9a-7f859bf6c3cf HTTP/1.1
        user-agent: curl/7.27.0
        host: 0.0.0.0:8080
        accept: */*
        --
        HTTP/1.1 200 OK
        content-type: application/json
        content-length: 7842
        content-md5: Z+XMCqoiyRTX0Oy88MJA9Q==
    ...
    ...


### Filtering Server heartbeats

There is an additional filter condition that can be used to analyse VMAPI logs.
A single heartbeat contains only VMs data for a single server. This means that
there is a 1:1 correspondence between a heartbeat message and a server. In the
event that VMAPI is receiving heartbeats for many servers, the `server` condition
allows a further filtering in the heartbeater module when operators need to
review the heartbeats coming from a specific server (and even as a way to check
if the heartbeats are actually arriving).

Similar to our previous examples, logs can be filtered by server with the
`server` condition:

    cat tmp/local.log | bunyan -c "this.server === '564d3d49-9bb1-3726-a1ea-b265db3a7f39'"

    [2013-03-12T16:46:20.009Z] TRACE: vmapi/heartbeater/79487: Missing VMs list for server 564d3d49-9bb1-3726-a1ea-b265db3a7f39: [] (server=564d3d49-9bb1-3726-a1ea-b265db3a7f39)
    [2013-03-12T16:46:30.019Z] DEBUG: vmapi/heartbeater/79487: (server=564d3d49-9bb1-3726-a1ea-b265db3a7f39)
        Heartbeat received from 564d3d49-9bb1-3726-a1ea-b265db3a7f39 { headers: {},
          deliveryInfo:
           { contentType: 'application/json',
             queue: 'heartbeat.vmapi',
             deliveryTag: 29,
             redelivered: false,
             exchange: 'amq.topic',
             routingKey: 'heartbeat.564d3d49-9bb1-3726-a1ea-b265db3a7f39',
             consumerTag: 'node-amqp-79487-0.5261222147382796' } }
    [2013-03-12T16:46:30.033Z] TRACE: vmapi/heartbeater/79487: (server=564d3d49-9bb1-3726-a1ea-b265db3a7f39)
        Current VMs list for server 564d3d49-9bb1-3726-a1ea-b265db3a7f39: [ 'c995fa61-2754-4e6d-a00d-a78a8cdad9ac',
          '5f6ae9c6-f817-48b0-9b48-03c5bcabd8d2',
          '638bed60-d59d-4654-a5aa-e6702cb2eb21',
          'ac3e34bc-cece-4134-a124-e035ad652093',
          ...


## Use Cases and Examples

The following examples make use of the `json` tool (https://github.com/trentm/json)
as a very convenient way to "pretty print" the output produced by VMAPI. In addition,
we assume VMAPI is being queried from an SDC Compute Node, thus implying the availability
of the sdc-vmapi command.

### Counting VMs

Use the HEAD HTTP method to get the number of VMs that match a specific criteria.
If HEAD is used, VMAPI won't return any objects as specified by the HTTP standard.
The number of VMs that match the query will be available as the **x-joyent-resource-count**
response header

*Count all VMs:*

    sdc-vmapi /vms -X HEAD

    HTTP/1.1 200 OK
    x-joyent-resource-count: 21
    Connection: close
    Date: Tue, 26 Mar 2013 09:54:21 GMT

*Count all 128M Vms:*

    sdc-vmapi /vms -X HEAD

    HTTP/1.1 200 OK
    x-joyent-resource-count: 8
    Connection: close
    Date: Tue, 26 Mar 2013 09:54:21 GMT

### Query String vs LDAP Search Query

Use a query string when you need to match specific values for VM attributes.
Examples of this are "ram=128" or "alias=my-vm". This is the classic behavior
for passing data values to an HTTP API and it allows client UIs to have tables
that display data that can be filtered by any given attribute.

VMAPI also allows clients to pass an LDAP search query that can be used when just
the equality operator is not enough. As an example, one might neeed to get the
UUIDs of all machines that have less than or equal to 256M of RAM:

    sdc-vmapi "/vms?query=(ram<=256)" | json -H -a uuid ram

    6472ed54-0783-4b2a-b052-ed2991284314 256
    c6de897f-c5af-4dd2-9659-c1893c95ca31 128
    20aaee31-7f94-4a5a-b724-48a5b42d4066 128
    dfcbc0d4-b423-4f13-9583-d6e87aae5801 256
    cc57ab8b-1f50-4779-828a-2a0109aed360 256
    d848d326-2502-4200-ace8-8830259f4ef1 128
    ae21f197-a005-476f-9423-b5d63279686f 128
    b95db5f7-8b02-472c-a6cc-719bc7566b2a 128
    47c36d58-b5b8-4e4d-a505-080feeea3386 128
    a564b236-b158-4231-b060-9a24ba0c257e 128
    720426ef-82de-4289-9813-44f0badf0b06 128

Or we can also find all the machines created in a period of time:

    sdc-vmapi "/vms?query=(%26(create_timestamp<=1364329137198)(create_timestamp>=1354321137198))" | json -H -a alias

    assets0
    sapi0
    zookeeper0
    manatee0
    moray0
    redis0
    ufds0
    workflow0
    amon0
    napi0
    rabbitmq0
    imgapi0
    cnapi0
    dhcpd0
    dapi0
    fwapi0
    vmapi0
    ca0
    adminui0
    usageapi0

TODO: modifying vms

## Debugging Common Issues

### VMAPI has no VMs, or VMs are not being updated

This is almost always an issue with the heartbeater, since VMAPI should always
have VMs. Even if VMs are not created from VMAPI they are discovered by the
heartbeater.

**What To Do?**

* Make sure the heartbeater is having problems to process data. Check the VMAPI
service log file and see if there are any errors being logged in it.

* If there are no errors logged by VMAPI then check the heartbeater agent and
confirm it is sending out heartbeats. If not, restart the agent with `svcadm restart heartbeater`

* Optionally (if the heartbeater agent was working): force a heartbeat cache refresh when the cache client is configured to use redis

Refresh the Redis cache with the following commands (starting from the global zone):

    sdc-login redis
    /opt/redis/bin/redis-cli
    > select 4
    > flushdb

TODO: job failed

TODO: provision failed

TODO: vm destroyed but still there

# Changelog

## 2013-04-30

  * Property *resolvers* added to VM response object

## 2013-04-29

  * Added *reprovision* action to POST /vms/:uuid

## 2013-03-11

  * Added *status* to /ping response

## 2013-02-04

  * Added process *pid* to /ping response

## 2012-12-18

  * Added support for delete_snapshot
  * Updated endpoints for create_snapshot and rollback_snapshot. They are now part of UpdateVm

## 2012-12-13

  * Added support add_nics and remove_nics on UpdateVm

## 2012-11-30

  * Added support for advanced search on ListVms (LDAP search filters)

## 2012-11-21

  * New /ping endpoint to report on service status

## 2012-11-19

  * VM response object now returns the snapshot property for vms

## 2012-11-08

  * updateVm endpoint now takes new_owner_uuid instead of owner_uuid to indicate the new owner of the VM

## 2012-10-18

  * Added snapshot and rollback support

## 2012-09-11

  * Updating VM metadata with an updateVm operation replaces existing metadata. It is no longer an append

## 2012-08-29

  * Adds an error response when trying to delete unallocated VMs

## 2012-08-10

  * Added new format for networks parameter in CreateVm. See deprecation note

## 2012-08-08

  * Added /statuses

## 2012-06-12

  * Added /jobs and /vms/:uuid/jobs

## 2012-06-11

  * dataset_uuid is deprecated. image_uuid should now be used
  * Added SetMetadata (PUT /vms/:uuid/:metadata)

## 2012-06-07

  * Reverted dataset_url as a allowed parameter
  * Can now pass nics as a parameter. Will override networks

## 2012-06-06

  * Brand 'joyent-minimal' is now supported

## 2012-06-05

  * When creating a new VM you can now pass dataset_url
  * When creating a new VM you can now pass server_uuid

## 2012-06-04

  * VM actions now return a Job Response Object

## 2012-06-01

  * VM API endpoints are now named /vms instead of /machines
  * /machines is still aliased but deprecated

## 2012-05-28

  * Search VMs by tags

## 2012-05-23

  * 'networks' is a required parameter for POST /vms
  * Add sync=true parameter to GET /vms/uuid

## 2012-05-22

  * Add sync=true parameter to DELETE /vms/uuid
