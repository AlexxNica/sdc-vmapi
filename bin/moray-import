#!/opt/smartdc/vmapi/build/node/bin/node
// -*- mode: js -*-

/*
 * Copyright (c) 2012, Joyent, Inc. All rights reserved.
 *
 * A brief overview of this source file: what is its purpose.
 */

var fs = require('fs');
var path = require('path');

var bunyan = require('bunyan');
var getopt = require('posix-getopt');
var uuid = require('node-uuid');

var async = require('async');
var moray = require('moray');



///--- Globals

var LOG = bunyan.createLogger({
	name: path.basename(process.argv[1]),
	level: (process.env.LOG_LEVEL || 'info'),
	stream: process.stderr,
	serializers: bunyan.stdSerializers
});

var CONFIG = loadConfig();
var BUCKET = 'vmapi_vms';
var DRY_RUN = false;


///--- Functions

/*
 * Loads and parse the configuration file at config.json
 */
function loadConfig() {
    var configPath = path.join(__dirname, '..', 'config.json');

    if (!fs.existsSync(configPath)) {
        console.error('Config file not found: ' + configPath +
          ' does not exist. Aborting.');
        process.exit(1);
    }

    var theConfig = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
    return theConfig;
}

/*
 * Loads the mapi dump file
 */
function loadDump(file) {
    if (!fs.existsSync(file)) {
        console.error('Dump file not found: ' + file +
          ' does not exist. Aborting.');
        process.exit(1);
    }

    var contents = fs.readFileSync(file, 'utf-8');
    return contents;
}


function usage(msg) {
    if (msg) {
        console.error(msg);
    }

    var str = 'usage: ' + path.basename(process.argv[1]);
    str += ' [-v] [-d ] [-f file]';
    console.error(str);
    process.exit(1);
}


function parseOptions() {
    var opts = {};
    var option;
    var parser = new getopt.BasicParser('vdf:', process.argv);
    var tmp;

    while ((option = parser.getopt()) !== undefined && !option.error) {
        switch (option.option) {
            case 'f':
                opts.file = option.optarg;
                break;

            case 'd':
                DRY_RUN = true;
                break;

            case 'v':
                // Allows us to set -vvv -> this little hackery
                // just ensures that we're never < TRACE
                LOG.level(Math.max(bunyan.TRACE, (LOG.level() - 10)));
                if (LOG.level() <= bunyan.DEBUG) {
                    LOG = LOG.child({ src: true });
                }
                break;

            default:
                break;
        }
    }

    if (!opts.file) {
        usage('"file" must be specified');
    }

    return (opts);
}


function parseObjects(string) {
    var i, obj;
    var array = string.split('\n');
    var vms = [];

    for (i = 0; i < array.length; i++) {
        if (array[i] !== '') {
            obj = JSON.parse(array[i]);
            vms.push(obj);
        }
    }

    return vms;
}

function finish(err) {
    if (MORAY) {
        MORAY.close();
    }

    if (err) {
        process.exit(1);
    } else {
        process.exit(0);
    }
}


///--- Mainline

var MORAY;
var options = parseOptions();
var data = loadDump(options.file);
var vms = parseObjects(data);

MORAY = moray.createClient({
    connectTimeout: 10000,
    log: LOG,
    host: CONFIG.moray.host,
    noCache: true,
    port: CONFIG.moray.port,
    retry: {
        retries: Infinity,
        minTimeout: 1000,
        maxTimeout: 60000
    }
});

function onMorayError(err) {
    return finish(err);
}

function onMorayConnect() {
    MORAY.removeListener('error', onMorayError);
    MORAY.on('close', function () {
        MORAY.log.error('moray: closed');
        finish();
    });

    MORAY.on('connect', function () {
        MORAY.log.info('moray: reconnected');
    });

    MORAY.on('error', function (err) {
        MORAY.log.warn(err, 'moray: error (reconnecting)');
    });

    putVms();
}

MORAY.once('connect', onMorayConnect);
MORAY.once('error', onMorayError);

function putVm(vm, next) {
    if (DRY_RUN === true) {
        console.log(JSON.stringify(vm));
        return next();
    }

    MORAY.putObject(BUCKET, vm.uuid, vm, function (err) {
        if (err) {
            LOG.error(err, 'Error importing VM %s', vm.uuid);
        } else {
            LOG.debug('VM %s added to moray', vm.uuid);
        }
        next(err);
    });
}

function putVms() {
    async.each(vms, putVm, function (err) {
        if (err) {
            LOG.error(err);
        } else {
            LOG.info('Finished importing VMs');
        }
        finish(err);
    });
}
